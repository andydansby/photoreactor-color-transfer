// plugin.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "IPlugin.h"
#include <math.h>
#include <stdlib.h>
////////////////////////////////////////////////////////////////////////
// A concrete plugin implementation
////////////////////////////////////////////////////////////////////////

// Photo-Reactor Plugin class

//****************************************************************************
//This code has been generated by the Mediachance photo reactor Code generator.


#define AddParameter(N,S,V,M1,M2,T,D) {strcpy (pParameters[N].m_sLabel,S);pParameters[N].m_dValue = V;pParameters[N].m_dMin = M1;pParameters[N].m_dMax = M2;pParameters[N].m_nType = T;pParameters[N].m_dSpecialValue = D;}

#define GetValue(N) (pParameters[N].m_dValue)
#define GetValueY(N) (pParameters[N].m_dSpecialValue)

#define SetValue(N,V) {pParameters[N].m_dValue = V;}

#define GetBOOLValue(N) ((BOOL)(pParameters[N].m_dValue==pParameters[N].m_dMax))

// if it is not defined, then here it is
//#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))




#define PARAM_TYPE_NR0	0
#define PARAM_STRENGTH_NR1	1
#define PARAM_STYLE_NR2	2
#define NUMBER_OF_USER_PARAMS 3

class PluginTest : public IPlugin	
{
public:




	// constructor
	PluginTest()
	{



	}


		//Plugin Icon:
	//you can add your own icon by creating 160x100 png file, naming it the same as plugin dll and then placing it in the plugins folder
	//otherwise a generic icon will be used 

	//this is the title of the box in workspace. it should be short
	const char* GetTitle () const
	{
		return "Color Xfer";
	}
	
	// this will appear in the help pane, you can put your credits and short info
	const char* GetDescription () const
	{
		return "Color Transfer Between Images.  The original algorythm was published by Erik Reinhard, Michael Ashikhmin, Bruce Gooch, and Peter Shirley from the University of Utah.  This routine gathers the mean and standard deviation of a second image's colors and apply's it to the target image.  The actual color transfer formula looks amazingly like a white balance, using a secondary image as guidance. Included in this plugin are various Color Spaces and a strength dial to dial down the enhancement.";
	}

	// BASIC PARAMETERS
	// number of inputs 0,1 or 2
	int GetInputNumber ()
	{
		return 2;
	}

	// number of outputs 0 or 1
	int GetOutputNumber ()
	{
		return 1;
	}

	int GetBoxColor ()
	{
		return RGB(56,61,72);
	}

	int GetTextColor ()
	{
		return RGB(130,130,130);
	}

	// width of the box in the workspace
	// valid are between 50 and 100
	int GetBoxWidth ()
	{
		return 70;
	}

	// set the flags
	// see the interface builder
	// ex: nFlag = FLAG_FAST_PROCESS | FLAG_HELPER;

	//FLAG_NONE same as zero	Default, no other flags set
	//FLAG_UPDATE_IMMEDIATELY	It is very fast process that can update immediately. When user turns the sliders on UI the left display will update
	//							Use Update Immediately only for fast and single loop processes, for example Desaturate, Levels.
	//FLAG_HELPER				It is an helper object. Helper objects will remain visible in Devices and they can react to mouse messages. Example: Knob, Monitor, Bridge Pin
	//FLAG_BINDING				Binding object, attach to other objects and can change its binding value. It never goes to Process_Data functions.  Example: Knob, Switch, Slider
	//FLAG_DUMMY				It is only for interface but never process any data. Never goes to Process_Data functions. Example: Text note
	//FLAG_SKIPFINAL			Process data only during designing, doesn't process during final export. Example: Monitor, Vectorscope 
	//FLAG_LONGPROCESS			Process that takes > 1s to finish. Long Process will display the Progress dialog and will prevent user from changing values during the process.
	//FLAG_NEEDSIZEDATA		    Process need to know size of original image, the zoom and what part of image is visible in the preview. When set the plugin will receive SetSizeData
	//FLAG_NEEDMOUSE			Process will receive Mouse respond data from the workplace. This is only if your object is interactive, for example Knob, Slider
	
	// addition in 5/29/2013
	// very special case (BETA):
	//FLAG_GETMAINIMAGERGBA		Process_Data will always receive full Main Image as the input buffer in the UP RGBA format (! different than normal BGRA upside down buffer), 
	//							Needs GetInputNumber  = 0 as it doesn't process buffer from the input node at all. 

	int GetFlags ()
	{
		// it is fast process
		int nFlag = FLAG_NONE;

		nFlag = nFlag | FLAG_UPDATE_IMMEDIATELY;
		nFlag = nFlag | FLAG_HELPER;


		
		return nFlag;
	}


	// User Interface Build
	// there is maximum 29 Parameters

	int GetUIParameters (UIParameters* pParameters)
	{

		// label, value, min, max, type_of_control, special_value
		// use the UI builder in the software to generate this


		AddParameter( PARAM_TYPE_NR0 ,"lab|CIE LAB|XYZ|YCbCr", 0, 0, 3, TYPE_ONEOFMANY, 0);
		AddParameter( PARAM_STRENGTH_NR1 ,"Strength", 100.0, 0.0, 100.0, TYPE_SLIDER, 0.0);
		AddParameter( PARAM_STYLE_NR2 ,"Reinhard Formula|Andy's Formula", 0, 0, 1, TYPE_ONEOFMANY, 0);
		

		return NUMBER_OF_USER_PARAMS;
	}
	

	// Actual processing function for 1 input
	//***************************************************************************************************
	// Both buffers are the same size
	// don't change the IN buffer or things will go bad for other objects in random fashion
	// the pBGRA_out comes already with pre-copied data from pBGRA_in
	// Note: Don't assume the nWidth and nHeight will be every run the same or that it contains the whole image!!!! 
	// This function receives buffer of the actual preview (it can be just a crop of image when zoomed in) and during the final calculation of the full buffer
	virtual void Process_Data (BYTE* pBGRA_out,BYTE* pBGRA_in, int nWidth, int nHeight, UIParameters* pParameters)
	{
		// this is just example to desaturate and to adjust the desaturation with slider
		// Get the latest parameters

		//List of Parameters
		int ColorSpace = (int)GetValue(PARAM_TYPE_NR0);
	}

	// actual processing function for 2 inputs
	//********************************************************************************
	// all buffers are the same size
	// don't change the IN buffers or things will go bad
	// the pBGRA_out comes already with copied data from pBGRA_in1
	virtual void Process_Data2 (BYTE* pBGRA_out, BYTE* pBGRA_in1, BYTE* pBGRA_in2, int nWidth, int nHeight, UIParameters* pParameters)
	{
		int ColorSpace = (int)GetValue(PARAM_TYPE_NR0);
		double strength = (double)GetValue(PARAM_STRENGTH_NR1);
		int style = (int)GetValue(PARAM_STYLE_NR2);


		double fcolorspace = 255.0f;

		double meanRedTargetImage = 0;
		double meanGreenTargetImage = 0;
		double meanBlueTargetImage = 0;
		double meanRedReferenceImage = 0;
		double meanGreenReferenceImage = 0;
		double meanBlueReferenceImage = 0;

		double standarddeviationRedTargetImage = 0;
		double standarddeviationGreenTargetImage = 0;
		double standarddeviationBlueTargetImage = 0;
		double standarddeviationRedReferenceImage = 0;
		double standarddeviationGreenReferenceImage = 0;
		double standarddeviationBlueReferenceImage = 0;

		double* targetImage=new double[nWidth * nHeight * 4]; // this is our tempory buffer to hold image 1
		double* referenceImage=new double[nWidth * nHeight * 4]; // this is our tempory buffer to hold image 2

		//default array
		for (int x = 0; x< nWidth; x++)
		{
			for (int y = 0; y< nHeight; y++)
			{
					int nIdx = x * 4 + y * 4 * nWidth;
					targetImage[nIdx + CHANNEL_R] = 0;
					targetImage[nIdx + CHANNEL_G] = 0;
					targetImage[nIdx + CHANNEL_B] = 0;
					referenceImage[nIdx + CHANNEL_R] = 0;
					referenceImage[nIdx + CHANNEL_G] = 0;
					referenceImage[nIdx + CHANNEL_B] = 0;
			}
		}

		if (ColorSpace == 0)
#pragma region   // use alternate LAB
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					//read in image 1
					double red1 = pBGRA_in1[nIdx+CHANNEL_R] / fcolorspace;
					double green1 = pBGRA_in1[nIdx+CHANNEL_G] / fcolorspace;
					double blue1 = pBGRA_in1[nIdx+CHANNEL_B] / fcolorspace;
					//read in image 2
					double red2 = pBGRA_in2[nIdx+CHANNEL_R] / fcolorspace;
					double green2 = pBGRA_in2[nIdx+CHANNEL_G] / fcolorspace;
					double blue2 = pBGRA_in2[nIdx+CHANNEL_B] / fcolorspace;

					//first we will convert the RGB image to LMS with a matrix
					//image 1
					double lmsL1 = (0.3811 * red1) + (0.5783 * green1) + (0.0402 * blue1);
					double lmsM1 = (0.1967 * red1) + (0.7244 * green1) + (0.0782 * blue1);
					double lmsS1 = (0.0241 * red1) + (0.1288 * green1) + (0.8444 * blue1);				
					//image 2
					double lmsL2 = (0.3811 * red2) + (0.5783 * green2) + (0.0402 * blue2);
					double lmsM2 = (0.1967 * red2) + (0.7244 * green2) + (0.0782 * blue2);
					double lmsS2 = (0.0241 * red2) + (0.1288 * green2) + (0.8444 * blue2);

					//convert LMS to LAB part 1
					//image 1
					double labL1 = 1.0 / sqrt(3.0) * lmsL1;
					double labA1 = 1.0 / sqrt(6.0) * lmsM1;
					double LabB1 = 1.0 / sqrt(2.0) * lmsS1;
					//image 2
					double labL2 = 1.0 / sqrt(3.0) * lmsL2;
					double labA2 = 1.0 / sqrt(6.0) * lmsM2;
					double LabB2 = 1.0 / sqrt(2.0) * lmsS2;

					//convert LMS to LAB part 2
					double labL11 = (labL1 * 1.0) + (labA1 * 1.0) + (LabB1 * 1.0);
					double labA11 = (labL1 * 1.0) + (labA1 * 1.0) + (LabB1 * -2.0);
					double labB11 = (labL1 * 1.0) + (labA1 * -1.0) + (LabB1 * 0.0);
					double labL22 = (labL2 * 1.0) + (labA2 * 1.0) + (LabB2 * 1.0);
					double labA22 = (labL2 * 1.0) + (labA2 * 1.0) + (LabB2 * -2.0);
					double LabB22 = (labL2 * 1.0) + (labA2 * -1.0) + (LabB2 * 0.0);


					//we are now in the LAB colorspace
					//TargetImage
					double RlabL1 = labL11 * fcolorspace;
					double RlabA1 = labA11 * fcolorspace;
					double RlabB1 = labB11 * fcolorspace;
					//image 2
					double RlabL2 = labL22 * fcolorspace;
					double RlabA2 = labA22 * fcolorspace;
					double RlabB2 = LabB22 * fcolorspace;

					//place LAB image in temp array
					targetImage [nIdx + CHANNEL_R] = RlabL1;
					targetImage [nIdx + CHANNEL_G] = RlabA1;
					targetImage [nIdx + CHANNEL_B] = RlabB1;					
					referenceImage [nIdx + CHANNEL_R] = RlabL2;
					referenceImage [nIdx + CHANNEL_G] = RlabA2;
					referenceImage [nIdx + CHANNEL_B] = RlabB2;
				}
			}
		}
#pragma endregion

		if (ColorSpace == 1)
#pragma region          // using CIE LAB
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					double red1;
					double green1;
					double blue1;
					double red2;
					double green2;
					double blue2;
					double xyzX1;
					double xyzY1;
					double xyzZ1;

					double xyzX2;
					double xyzY2;
					double xyzZ2;

					double var_X1;
					double var_Y1;
					double var_Z1;
					double var_X2;
					double var_Y2;
					double var_Z2;

					double refX;
					double refY;
					double refZ;

					double var_X11;
					double var_Y12;
					double var_Z13;
					double var_X21;
					double var_Y22;
					double var_Z23;

					//read in image 1
					red1   = double(pBGRA_in1[nIdx + CHANNEL_R]) / fcolorspace;
					green1 = double(pBGRA_in1[nIdx + CHANNEL_G]) / fcolorspace;
					blue1  = double(pBGRA_in1[nIdx + CHANNEL_B]) / fcolorspace;

					//read in image 2
					red2   = double(pBGRA_in2[nIdx + CHANNEL_R]) / fcolorspace;
					green2 = double(pBGRA_in2[nIdx + CHANNEL_G]) / fcolorspace;
					blue2  = double(pBGRA_in2[nIdx + CHANNEL_B]) / fcolorspace;

					//adjust gamma on image 1
					if (red1 > 0.04045f)
					{ 
						red1 = powf((red1 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						red1 = red1 / 12.92f; 
					}
					if (green1 > 0.04045f)
					{ 
						green1 = powf((green1 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						green1 = green1 / 12.92f; 
					}
					if (blue1 > 0.04045f)
					{ 
						blue1 = powf((blue1 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{	
						blue1 = blue1 / 12.92f; 
					}

					if (red2 > 0.04045f)
					{ 
						red2 = powf((red2 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						red2 = red2 / 12.92f; 
					}
					if ( green2 > 0.04045f)
					{ 
						green2 = powf((green2 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						green2 = green2 / 12.92f; 
					}
					if (blue2 > 0.04045f)
					{ 
						blue2 = powf((blue2 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{	
						blue2 = blue2 / 12.92f; 
					}


					//scale image 1
					red1   = red1   * 100.0f;
					green1 = green1 * 100.0f;
					blue1  = blue1  * 100.0f;
					//scale image 2
					red2   = red2   * 100.0f;
					green2 = green2 * 100.0f;
					blue2  = blue2  * 100.0f;

					//first we will convert the RGB image to XYZ
					//image 1
					xyzX1 = (0.412453f * red1) + (0.357580f * green1) + (0.180423f * blue1);
					xyzY1 = (0.212671f * red1) + (0.715160f * green1) + (0.072169f * blue1);
					xyzZ1 = (0.019334f * red1) + (0.119193f * green1) + (0.950227f * blue1);
					//image 2
					xyzX2 = (0.412453f * red2) + (0.357580f * green2) + (0.180423f * blue2);
					xyzY2 = (0.212671f * red2) + (0.715160f * green2) + (0.072169f * blue2);
					xyzZ2 = (0.019334f * red2) + (0.119193f * green2) + (0.950227f * blue2);

					//reference white
					refX = 95.047f; // Observer= 2°, Illuminant= D65
					refY = 100.000f; 
					refZ = 108.883f;

					//adjust LAB to reference white
					//image 1
					var_X1 = xyzX1 / refX;
					var_Y1 = xyzY1 / refY;
					var_Z1 = xyzZ1 / refZ;
					//image 2
					var_X2 = xyzX2 / refX;
					var_Y2 = xyzY2 / refY;
					var_Z2 = xyzZ2 / refZ;

					//LAB Conversion
					//image 1
					if (var_X1 > 0.008856f) 
					{
						var_X11 = powf(var_X1 , 1.0f/3.0f); 
					}
					else 
					{
						var_X11 = (7.787f * var_X1) + (16.0f/116.0f);
					}

					if (var_Y1 > 0.008856f) 
					{ 
						var_Y12 = powf(var_Y1 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Y12 = (7.787f * var_Y1) + (16.0f/116.0f);
					}

					if (var_Z1 > 0.008856f) 
					{
						var_Z13 = powf(var_Z1 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Z13 = (7.787f * var_Z1) + (16.0f/116.0f);
					}
					//image 2
					if (var_X2 > 0.008856f) 
					{
						var_X21 = powf(var_X2 , 1.0f/3.0f); 
					}
					else 
					{
						var_X21 = (7.787f * var_X2) + (16.0f/116.0f);
					}

					if (var_Y2 > 0.008856f) 
					{ 
						var_Y22 = powf(var_Y2 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Y22 = (7.787f * var_Y2) + (16.0f/116.0f);
					}

					if (var_Z2 > 0.008856f) 
					{
						var_Z23 = powf(var_Z2 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Z23 = (7.787f * var_Z2) + (16.0f/116.0f);
					}
 
					//adjust LAB scale
					//image 1
					double cieL1 = (116.0f * var_Y12) - 16.0f;
					double cieA1 = 500.0f * (var_X11 - var_Y12);
					double cieB1 = 200.0f * (var_Y12 - var_Z13);
					//image 2
					double cieL2 = (116.0f * var_Y22) - 16.0f;
					double cieA2 = 500.0f * (var_X21 - var_Y22);
					double cieB2 = 200.0f * (var_Y22 - var_Z23);


					//place LAB image in temp array
					targetImage[nIdx + CHANNEL_R] = cieL1;//int(cieL1);
					targetImage[nIdx + CHANNEL_G] = cieA1;//int(cieA1);
					targetImage[nIdx + CHANNEL_B] = cieB1;//int(cieB1);



					//place LAB image in temp array
					referenceImage[nIdx + CHANNEL_R] = cieL2;//int(cieL2);
					referenceImage[nIdx + CHANNEL_G] = cieA2;//int(cieA2);
					referenceImage[nIdx + CHANNEL_B] = cieB2;//int(cieB2);
				}
			}
		}
#pragma endregion

		if (ColorSpace == 2)
#pragma region   //use XYZ
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					double red1;
					double green1;
					double blue1;
					double red2;
					double green2;
					double blue2;
					double xyzX1;
					double xyzY1;
					double xyzZ1;

					double xyzX2;
					double xyzY2;
					double xyzZ2;

					//read in image 1
					red1   = double(pBGRA_in1[nIdx + CHANNEL_R]) / fcolorspace;
					green1 = double(pBGRA_in1[nIdx + CHANNEL_G]) / fcolorspace;
					blue1  = double(pBGRA_in1[nIdx + CHANNEL_B]) / fcolorspace;

					//read in image 2
					red2   = double(pBGRA_in2[nIdx + CHANNEL_R]) / fcolorspace;
					green2 = double(pBGRA_in2[nIdx + CHANNEL_G]) / fcolorspace;
					blue2  = double(pBGRA_in2[nIdx + CHANNEL_B]) / fcolorspace;

					//first we will convert the RGB image to XYZ
					//image 1
					xyzX1 = (0.436052025f * red1) + (0.385081593f * green1) + (0.143087414f * blue1);
					xyzY1 = (0.222491598f * red1) + (0.716886060f * green1) + (0.060621486f * blue1);
					xyzZ1 = (0.013929122f * red1) + (0.097097002f * green1) + (0.714185470f * blue1);
					//image 2
					xyzX2 = (0.436052025f * red2) + (0.385081593f * green2) + (0.143087414f * blue2);
					xyzY2 = (0.222491598f * red2) + (0.716886060f * green2) + (0.060621486f * blue2);
					xyzZ2 = (0.013929122f * red2) + (0.097097002f * green2) + (0.714185470f * blue2);

					//place LAB image in temp array
					targetImage[nIdx + CHANNEL_R] = xyzX1;//int(cieL1);
					targetImage[nIdx + CHANNEL_G] = xyzY1;//int(cieA1);
					targetImage[nIdx + CHANNEL_B] = xyzZ1;//int(cieB1);

					//place LAB image in temp array
					referenceImage[nIdx + CHANNEL_R] = xyzX2;//int(cieL2);
					referenceImage[nIdx + CHANNEL_G] = xyzY2;//int(cieA2);
					referenceImage[nIdx + CHANNEL_B] = xyzZ2;//int(cieB2);
				}
			}
		}
#pragma endregion

		if (ColorSpace == 3)
#pragma region  //ycbcr
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					double red1;
					double green1;
					double blue1;
					double red2;
					double green2;
					double blue2;
					double ycbcrY1;
					double ycbcrB1;
					double ycbcrR1;

					double ycbcrY2;
					double ycbcrB2;
					double ycbcrR2;

					//read in image 1
					red1   = double(pBGRA_in1[nIdx + CHANNEL_R]) / fcolorspace;
					green1 = double(pBGRA_in1[nIdx + CHANNEL_G]) / fcolorspace;
					blue1  = double(pBGRA_in1[nIdx + CHANNEL_B]) / fcolorspace;

					//read in image 2
					red2   = double(pBGRA_in2[nIdx + CHANNEL_R]) / fcolorspace;
					green2 = double(pBGRA_in2[nIdx + CHANNEL_G]) / fcolorspace;
					blue2  = double(pBGRA_in2[nIdx + CHANNEL_B]) / fcolorspace;

					//first we will convert the RGB image to XYZ
					//image 1
					ycbcrY1 = (0.299f * red1) + (0.587f * green1) + (0.114f * blue1);
					ycbcrB1 = (-0.16874f * red1) + (-0.33126f * green1) + (0.50000f * blue1);
					ycbcrR1 = (0.50000f * red1) + (-0.41869f * green1) + (-0.08131f * blue1);
					//image 2
					ycbcrY2 = (0.299f * red2) + (0.587f * green2) + (0.114f * blue2);
					ycbcrB2 = (-0.16874f * red2) + (-0.33126f * green2) + (0.50000f * blue2);
					ycbcrR2 = (0.50000f * red2) + (-0.41869f * green2) + (-0.08131f * blue2);

					//place LAB image in temp array
					targetImage[nIdx + CHANNEL_R] = ycbcrY1;//int(cieL1);
					targetImage[nIdx + CHANNEL_G] = ycbcrB1;//int(cieA1);
					targetImage[nIdx + CHANNEL_B] = ycbcrR1;//int(cieB1);

					//place LAB image in temp array
					referenceImage[nIdx + CHANNEL_R] = ycbcrY2;//int(cieL2);
					referenceImage[nIdx + CHANNEL_G] = ycbcrB2;//int(cieA2);
					referenceImage[nIdx + CHANNEL_B] = ycbcrR2;//int(cieB2);
				}
			}
		}
#pragma endregion


#pragma region			//test for proof that the image is in temp
		for (int x = 0; x< nWidth; x++)
		{
			for (int y = 0; y< nHeight; y++)
			{
					int nIdx = x * 4 + y * 4 * nWidth;
				
					//int nR = targetImage [nIdx + CHANNEL_R];
					//int nG = targetImage [nIdx + CHANNEL_G];
					//int nB = targetImage [nIdx + CHANNEL_B];

					//int nR = referenceImage [nIdx + CHANNEL_R];
					//int nG = referenceImage [nIdx + CHANNEL_G];
					//int nB = referenceImage [nIdx + CHANNEL_B];

					//pBGRA_out[nIdx + CHANNEL_R] = CLAMP255(nB);
					//pBGRA_out[nIdx + CHANNEL_G] = CLAMP255(nB);
					//pBGRA_out[nIdx + CHANNEL_B] = CLAMP255(nB);				
			}
		}
#pragma endregion


#pragma region  //find the mean and standard deviation of the color information in each channel
		{
			double tempmeanR1 = 0;
			double tempmeanR2 = 0;
			double tempmeanG1 = 0;
			double tempmeanG2 = 0;
			double tempmeanB1 = 0;
			double tempmeanB2 = 0;
			double tempstddevR1 = 0;
			double tempstddevR2 = 0;
			double tempstddevG1 = 0;
			double tempstddevG2 = 0;
			double tempstddevB1 = 0;
			double tempstddevB2 = 0;

			double imagesize = nWidth * nHeight;

			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x * 4 + y * 4 * nWidth;

					tempmeanR1 += targetImage [nIdx + CHANNEL_R];
					tempmeanG1 += targetImage [nIdx + CHANNEL_G];
					tempmeanB1 += targetImage [nIdx + CHANNEL_B];

					tempmeanR2 += referenceImage [nIdx + CHANNEL_R];
					tempmeanG2 += referenceImage [nIdx + CHANNEL_G];
					tempmeanB2 += referenceImage [nIdx + CHANNEL_B];

					tempstddevR1 += targetImage [nIdx + CHANNEL_R] * targetImage [nIdx + CHANNEL_R];
					tempstddevG1 += targetImage [nIdx + CHANNEL_G] * targetImage [nIdx + CHANNEL_G];
					tempstddevB1 += targetImage [nIdx + CHANNEL_B] * targetImage [nIdx + CHANNEL_B];

					tempstddevR2 += referenceImage [nIdx + CHANNEL_R] * referenceImage [nIdx + CHANNEL_R];
					tempstddevG2 += referenceImage [nIdx + CHANNEL_G] * referenceImage [nIdx + CHANNEL_G];
					tempstddevB2 += referenceImage [nIdx + CHANNEL_B] * referenceImage [nIdx + CHANNEL_B];
				}
			}
			//image mean
			{
				meanRedTargetImage = tempmeanR1 / imagesize;
				meanGreenTargetImage = tempmeanG1 / imagesize;
				meanBlueTargetImage =  tempmeanB1 / imagesize;
				meanRedReferenceImage = tempmeanR2 / imagesize;
				meanGreenReferenceImage = tempmeanG2 / imagesize;
				meanBlueReferenceImage = tempmeanB2 / imagesize;
				standarddeviationRedTargetImage = tempstddevR1 / imagesize;
				standarddeviationGreenTargetImage = tempstddevG1 / imagesize;
				standarddeviationBlueTargetImage = tempstddevB1 / imagesize;
				standarddeviationRedReferenceImage = tempstddevR2 / imagesize;
				standarddeviationGreenReferenceImage = tempstddevG2 / imagesize;
				standarddeviationBlueReferenceImage = tempstddevB2 / imagesize;				
			}
			//image standard deviation
			{
				tempstddevR1 = sqrtf(standarddeviationRedTargetImage - meanRedTargetImage * meanRedTargetImage);
				tempstddevG1 = sqrtf(standarddeviationGreenTargetImage - meanGreenTargetImage * meanGreenTargetImage);
				tempstddevB1 = sqrtf(standarddeviationBlueTargetImage - meanBlueTargetImage * meanBlueTargetImage);
				tempstddevR2 = sqrtf(standarddeviationRedReferenceImage - meanRedReferenceImage * meanRedReferenceImage);
				tempstddevG2 = sqrtf(standarddeviationGreenReferenceImage - meanGreenReferenceImage * meanGreenReferenceImage);
				tempstddevB2 = sqrtf(standarddeviationBlueReferenceImage - meanBlueReferenceImage * meanBlueReferenceImage); 
			}

			standarddeviationRedTargetImage = tempstddevR1;
			standarddeviationGreenTargetImage = tempstddevG1;
			standarddeviationBlueTargetImage = tempstddevB1;

			standarddeviationRedReferenceImage = tempstddevR2;
			standarddeviationGreenReferenceImage = tempstddevG2;
			standarddeviationBlueReferenceImage = tempstddevB2;
		}
#pragma endregion


		delete [] referenceImage;//delete the array

		double* enhancedimage=new double[nWidth * nHeight * 4];
		for (int x = 0; x< nWidth; x++)
		{
			for (int y = 0; y< nHeight; y++)
			{
					int nIdx = x * 4 + y * 4 * nWidth;
					enhancedimage[nIdx + CHANNEL_R] = 0;
					enhancedimage[nIdx + CHANNEL_G] = 0;
					enhancedimage[nIdx + CHANNEL_B] = 0;
			}
		}

#pragma region			//Color transfer
		for (int x = 0; x< nWidth; x++)
		{
			for (int y = 0; y< nHeight; y++)
			{
				int nIdx = x * 4 + y * 4 * nWidth;

				
				if (style == 0)//original Reinhard
				{
					enhancedimage [nIdx + CHANNEL_R] = (targetImage [nIdx + CHANNEL_R] - meanRedTargetImage)   / standarddeviationRedTargetImage   * standarddeviationRedReferenceImage   + meanRedReferenceImage;
					enhancedimage [nIdx + CHANNEL_G] = (targetImage [nIdx + CHANNEL_G] - meanGreenTargetImage) / standarddeviationGreenTargetImage * standarddeviationGreenReferenceImage + meanGreenReferenceImage;
					enhancedimage [nIdx + CHANNEL_B] = (targetImage [nIdx + CHANNEL_B] - meanBlueTargetImage)  / standarddeviationBlueTargetImage  * standarddeviationBlueReferenceImage  + meanBlueReferenceImage;
					//target = (target - mean_target) / standarddeviation_target * standarddeviation_reference + mean_reference
				}
				if (style == 1)//alt 1
				{
					enhancedimage [nIdx + CHANNEL_R] = (targetImage [nIdx + CHANNEL_R] - meanRedTargetImage)   * standarddeviationRedTargetImage   / standarddeviationRedTargetImage   + meanRedReferenceImage;
					enhancedimage [nIdx + CHANNEL_G] = (targetImage [nIdx + CHANNEL_G] - meanGreenTargetImage) * standarddeviationGreenTargetImage / standarddeviationGreenTargetImage + meanGreenReferenceImage;
					enhancedimage [nIdx + CHANNEL_B] = (targetImage [nIdx + CHANNEL_B] - meanBlueTargetImage)  * standarddeviationBlueTargetImage  / standarddeviationBlueTargetImage  + meanBlueReferenceImage;
				}

				if (style == 2)//alt 1
				{
					enhancedimage [nIdx + CHANNEL_R] = (targetImage [nIdx + CHANNEL_R] + meanRedReferenceImage)   * standarddeviationRedReferenceImage   / standarddeviationRedTargetImage   - meanRedTargetImage;
					enhancedimage [nIdx + CHANNEL_G] = (targetImage [nIdx + CHANNEL_G] + meanGreenReferenceImage) * standarddeviationGreenReferenceImage / standarddeviationGreenTargetImage - meanGreenTargetImage;
					enhancedimage [nIdx + CHANNEL_B] = (targetImage [nIdx + CHANNEL_B] + meanBlueReferenceImage)  * standarddeviationBlueReferenceImage  / standarddeviationBlueTargetImage  - meanBlueTargetImage;
				}

			}
		}

		delete [] targetImage;//move this to behind color transfer to release memory earlier
		

#pragma endregion

		if (ColorSpace == 0)
#pragma region  //use alternative lab
		{
			for (int x = 0; x< nWidth; x++)
			{
				for (int y = 0; y< nHeight; y++)
				{
					int nIdx = x * 4 + y * 4 * nWidth;

					double red;
					double green;
					double blue;

					double labL1 = enhancedimage [nIdx + CHANNEL_R];
					double LabA1 = enhancedimage [nIdx + CHANNEL_G];
					double LabB1 = enhancedimage [nIdx + CHANNEL_B];

					double labL11 = (0.333 * labL1) + (0.167 * LabA1) + (0.500 * LabB1);
					double labA11 = (0.333 * labL1) + (0.167 * LabA1) + (-0.500 * LabB1);
					double labB11 = (0.333 * labL1) + (-0.333 * LabA1) + (0.000 * LabB1);

					double lmsL1 = labL11 * 1.73205080;
					double lmsM1 = labA11 * 2.44948974;
					double lmsS1 = labB11 * 1.41421356;


					double rgbR = (lmsL1 * 4.4679) + (lmsM1 * -3.5873) + (lmsS1 * 0.1193);
					double rgbG = (lmsL1 * -1.2186) + (lmsM1 * 2.3809) + (lmsS1 * -0.1624);
					double rgbB = (lmsL1 * 0.0497) + (lmsM1 * -0.2439) + (lmsS1 * 1.2045);

					red = CLAMP255(rgbR);
					green = CLAMP255(rgbG);
					blue = CLAMP255(rgbB);

					enhancedimage[nIdx + CHANNEL_R] = red;
					enhancedimage[nIdx + CHANNEL_G] = green;
					enhancedimage[nIdx + CHANNEL_B] = blue;	
				}
			}
		}
#pragma endregion

		if (ColorSpace == 1)
#pragma region			//CIE LAB
		{
			for (int x = 0; x< nWidth; x++)
			{
				for (int y = 0; y< nHeight; y++)
				{
					int nIdx = x * 4 + y * 4 * nWidth;

					double refX;
					double refY;
					double refZ;

					double var_X;
					double var_Y;
					double var_Z;

					double cieX;
					double cieY;
					double cieZ;

					double red;
					double green;
					double blue;

					//reference white
					refX = 95.047f; // Observer= 2°, Illuminant= D65
					refY = 100.000f; 
					refZ = 108.883f;

					double cieL = enhancedimage [nIdx + CHANNEL_R];
					double cieA = enhancedimage [nIdx + CHANNEL_G];
					double cieB = enhancedimage [nIdx + CHANNEL_B];

					var_Y = (cieL + 16.0f) / 116.0f;
					var_X = cieA / 500.0f + var_Y;
					var_Z = var_Y - cieB / 200.0f;

					if (powf(var_Y, 3.0f) > 0.008856)
					{ 
						var_Y = powf(var_Y, 3.0f); 
					}
					else 
					{ 
						var_Y = (var_Y - 16.0f / 116.0f) / 7.787f; 
					}
					if (powf(var_X , 3.0f) > 0.008856f) 
					{ 
						var_X = powf(var_X, 3.0f); 
					}
					else 
					{ 
						var_X = (var_X - 16.0f / 116.0f) / 7.787f; 
					}
					if (powf(var_Z, 3.0f) > 0.008856 ) 
					{
						var_Z = powf(var_Z, 3.0f); 
					}
					else 
					{
						var_Z = (var_Z - 16.0f / 116.0f ) / 7.787f; 
					}

					cieX = refX * var_X;
					cieY = refY * var_Y;
					cieZ = refZ * var_Z;

					var_X = cieX / 100.0f;        
					var_Y = cieY / 100.0f;        
					var_Z = cieZ / 100.0f;

					red   = (var_X * 3.240479f)  + (var_Y * -1.537150f) + (var_Z * -0.498535f);
					green = (var_X * -0.969256f) + (var_Y * 1.87599f)  + (var_Z * 0.041556f);
					blue  = (var_X * 0.055648f)  + (var_Y * -0.204043f) + (var_Z * 1.057311f);

					if (red > 0.0031308f) 
					{ 
						red = 1.055f * powf(red , (1.0f / 2.4f)) - 0.055f; 
					}
					else 
					{ 
						red = 12.92f * red; 
					}
					if (green > 0.0031308f) 
					{ 
						green = 1.055f * powf(green , (1.0f / 2.4f)) - 0.055f; 
					}
					else 
					{ 
						green = 12.92f * green; 
					}
					if (blue > 0.0031308f) 
					{ 
						blue = 1.055f * powf(blue , (1.0f / 2.4f)) - 0.055f; 
					}
					else 
					{
						blue = 12.92f * blue; 
					}
					

					red = CLAMP255(red * fcolorspace);
					green = CLAMP255(green * fcolorspace);
					blue = CLAMP255(blue * fcolorspace);

					enhancedimage[nIdx + CHANNEL_R] = red;
					enhancedimage[nIdx + CHANNEL_G] = green;
					enhancedimage[nIdx + CHANNEL_B] = blue;	
				}
			}
		}
#pragma endregion

		if (ColorSpace == 2)
#pragma region   //use XYZ
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					double red;
					double green;
					double blue;

					double red1 = enhancedimage [nIdx + CHANNEL_R];
					double green1 = enhancedimage [nIdx + CHANNEL_G];
					double blue1 = enhancedimage [nIdx + CHANNEL_B];

					double rgbR = (3.134051341f * red1) + (-1.617027711f * green1) + (-0.490652210f * blue1);
					double rgbG = (-0.978762730f * red1) + (1.916142228f * green1) + (0.033449629f * blue1);
					double rgbB = (0.071942577f * red1) + (-0.228971180f * green1) + (1.405218305f * blue1);

					red = CLAMP255(rgbR * fcolorspace);
					green = CLAMP255(rgbG * fcolorspace);
					blue = CLAMP255(rgbB * fcolorspace);

					enhancedimage[nIdx + CHANNEL_R] = red;
					enhancedimage[nIdx + CHANNEL_G] = green;
					enhancedimage[nIdx + CHANNEL_B] = blue;	
				}
			}
		}
#pragma endregion

		if (ColorSpace == 3)
#pragma region   //use ycbcr
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					double red;
					double green;
					double blue;

					double red1 = enhancedimage [nIdx + CHANNEL_R];
					double green1 = enhancedimage [nIdx + CHANNEL_G];
					double blue1 = enhancedimage [nIdx + CHANNEL_B];

					double rgbR = (1.00000f * red1) + (-0.00001f * green1) + (1.40200f * blue1);
					double rgbG = (1.00000f * red1) + (-0.34413f * green1) + (-0.71414f * blue1);
					double rgbB = (1.00000f * red1) + (1.77200f * green1) + (0.00002f * blue1);

					red = CLAMP255(rgbR * fcolorspace);
					green = CLAMP255(rgbG * fcolorspace);
					blue = CLAMP255(rgbB * fcolorspace);

					enhancedimage[nIdx + CHANNEL_R] = red;
					enhancedimage[nIdx + CHANNEL_G] = green;
					enhancedimage[nIdx + CHANNEL_B] = blue;	
				}
			}
		}
#pragma endregion

		//we need to stretch the histogram on luminance only
		{
			for (int x = 0; x< nWidth; x++)
			{
				for (int y = 0; y< nHeight; y++)
				{
					int nIdx = x * 4 + y * 4 * nWidth;

					double red;
					double green;
					double blue;

					double ycbcrY;
					double ycbcrB;
					double ycbcrR;

					red   = double(enhancedimage[nIdx + CHANNEL_R]) / fcolorspace;
					green = double(enhancedimage[nIdx + CHANNEL_G]) / fcolorspace;
					blue  = double(enhancedimage[nIdx + CHANNEL_B]) / fcolorspace;

					ycbcrY = (0.299f * red) + (0.587f * green) + (0.114f * blue);
					ycbcrB = (-0.16874f * red) + (-0.33126f * green) + (0.50000f * blue);
					ycbcrR = (0.50000f * red) + (-0.41869f * green) + (-0.08131f * blue);

					enhancedimage[nIdx+CHANNEL_R] = ycbcrY;
					enhancedimage[nIdx+CHANNEL_G] = ycbcrB;
					enhancedimage[nIdx+CHANNEL_B] = ycbcrR;

				}
			}

			
			////////////////// MAX
			double maximumluma = 0.0f;

			////////////////// MIN
			double minimumluma = 1.0f;


			
			for (int x = 0; x< nWidth; x++)
			{
				for (int y = 0; y< nHeight; y++)
				{
					int nIdx = x * 4 + y * 4 * nWidth;

					double luma = enhancedimage[nIdx+CHANNEL_R];

					//find max
					if (luma > maximumluma) {maximumluma = luma;}

					//find min
					if (luma < minimumluma){minimumluma = luma;}
				}
			}

			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{				
					int nIdx = x*4+y*4*nWidth;
				
					double luma = enhancedimage[nIdx+CHANNEL_R];

					// clipping max value if over 255
					double luma2 = (luma - minimumluma) * (1) / (maximumluma - minimumluma) + .00001f;
					//if (luma2 > fcolorspace) { luma2 = fcolorspace;}


					enhancedimage[nIdx+CHANNEL_R] = luma2;
				}
			}

			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{				
					int nIdx = x*4+y*4*nWidth;

					double red;
					double green;
					double blue;

					double red1 = enhancedimage [nIdx + CHANNEL_R];
					double green1 = enhancedimage [nIdx + CHANNEL_G];
					double blue1 = enhancedimage [nIdx + CHANNEL_B];

					double rgbR = (1.00000f * red1) + (-0.00001f * green1) + (1.40200f * blue1);
					double rgbG = (1.00000f * red1) + (-0.34413f * green1) + (-0.71414f * blue1);
					double rgbB = (1.00000f * red1) + (1.77200f * green1) + (0.00002f * blue1);

					red = CLAMP255(rgbR * fcolorspace);
					green = CLAMP255(rgbG * fcolorspace);
					blue = CLAMP255(rgbB * fcolorspace);

					enhancedimage[nIdx + CHANNEL_R] = red;
					enhancedimage[nIdx + CHANNEL_G] = green;
					enhancedimage[nIdx + CHANNEL_B] = blue;

				}
			}
		}

		//output
		for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{				
					int nIdx = x*4+y*4*nWidth;
				
					double enhancedred = enhancedimage[nIdx+CHANNEL_R];
					double enhancedgreen = enhancedimage[nIdx+CHANNEL_G];
					double enhancedblue = enhancedimage[nIdx+CHANNEL_B];

					double originalred = pBGRA_in1[nIdx+CHANNEL_R];
					double originalgreen = pBGRA_in1[nIdx+CHANNEL_G];
					double originalblue = pBGRA_in1[nIdx+CHANNEL_B];

					//output = Bottomimage * MixingValue / 1.0 + Topimage * (1.0 - MixingValue) / 1.0;

					double red = enhancedred * strength / 100.0f + originalred * (100.0f - strength) / 100.0f;
					double green = enhancedgreen * strength / 100.0f + originalgreen * (100.0f - strength) / 100.0f;
					double blue = enhancedblue * strength / 100.0f + originalblue * (100.0f - strength) / 100.0f;


					pBGRA_out[nIdx+CHANNEL_R] = CLAMP255(red);
					pBGRA_out[nIdx+CHANNEL_G] = CLAMP255(green);
					pBGRA_out[nIdx+CHANNEL_B] = CLAMP255(blue);
				}
			}


		delete [] enhancedimage;//delete the array

	}


	//*****************Drawing functions for the BOX *********************************
	//how is the drawing handled
	//DRAW_AUTOMATICALLY	the main program will fully take care of this and draw a box, title, socket and thumbnail
	//DRAW_SIMPLE_A			will draw a box, title and sockets and call CustomDraw
	//DRAW_SIMPLE_B			will draw a box and sockets and call CustomDraw
	//DRAW_SOCKETSONLY      will call CustomDraw and then draw sockets on top of it
	
	// highlighting rectangle around is always drawn except for DRAW_SOCKETSONLY

	virtual int GetDrawingType ()
	{
		int nType = DRAW_AUTOMATICALLY;

		return nType;

	}


	// Custom Drawing
	// custom drawing function called when drawing type is different than DRAW_AUTOMATICALLY
	// it is not always in real pixels but scaled depending on where it is drawn
	// the scale could be from 1.0 to > 1.0
	// so you always multiply the position, sizes, font size, line width with the scale
	
	virtual void CustomDraw (HDC hDC, int nX,int nY, int nWidth, int nHeight, float scale, BOOL bIsHighlighted, UIParameters* pParameters)
	{

	}


	//************ Optional Functions *****************************************************************************************
	// those functions are not necessary for normal effect, they are mostly for special effects and objects


	// Called when FLAG_HELPER set. 
	// When UI data changed (user turned knob) this function will be called as soon as user finish channging the data
	// You will get the latest parameters and also which parameter changed
	// Normally for effects you don't have to do anything here because you will get the same parameters in the process function
	// It is only for helper objects that may not go to Process Data 
	BOOL UIParametersChanged (UIParameters* pParameters, int nParameter)
	{
		
		return FALSE;
	}

	// when button is pressed on UI, this function will be called with the parameter and sub button (for multi button line)
	BOOL UIButtonPushed (int nParam, int nSubButton, UIParameters* pParameters)
	{

		return TRUE;
	}

	// Called when FLAG_NEEDSIZEDATA set
	// Called before each calculation (Process_Data)
	// If your process depends on a position on a frame you may need the data to correctly display it because Process_Data receives only a preview crop
	// Most normal effects don't depend on the position in frame so you don't need the data
	// Example: drawing a circle at a certain position requires to know what is displayed in preview or the circle will be at the same size and position regardless of zoom
	
	// Note: Even if you need position but you don't want to mess with the crop data, just ignore it and pretend the Process_Data are always of full image (they are not). 
	// In worst case this affects only preview when using zoom. The full process image always sends the whole data

	// nOriginalW, nOriginalH - the size of the original - full image. If user sets Resize on input - this will be the resized image
	// nPreviewW, nPreviewH   - this is the currently processed preview width/height - it is the same that Process_Data will receive
	//                        - in full process the nPreviewW, nPreviewH is equal nOriginalW, nOriginalH
	// Crop X1,Y1,X2,Y2       - relative coordinates of preview crop rectangle in <0...1>, for full process they are 0,0,1,1 (full rectangle)	
	// dZoom                  - Zoom of the Preview, for full process the dZoom = 1.0
	void SetSizeData(int nOriginalW, int nOriginalH, int nPreviewW, int nPreviewH, double dCropX1, double dCropY1, double dCropX2, double dCropY2, double dZoom)
	{

		// so if you need the position and zoom, this is the place to get it.
		// Note: because of IBM wisdom the internal bitmaps are on PC always upside down, but the coordinates are not
		// which you  need to take into account. See rectangle demo project for more info 


	}


	// ***** Mouse handling on workplace *************************** 
	// only if FLAG_NEEDMOUSE is set
	//****************************************************************
	//this is for special objects that need to receive mouse, like a knob or slider on workplace
	// normally you use this for FLAG_BINDING objects

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonDown (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		


		// return FALSE if not handled
		// return TRUE if handled
		return FALSE;
	}

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseMove (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
	
		

			

		return FALSE;
	}
	
	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonUp (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// Note: if we changed data and need to recalculate the flow we need to return TRUE


		// return FALSE if not handled
		// return TRUE if handled
		
		return TRUE;
	}


};

extern "C"
{
	// Plugin factory function
	__declspec(dllexport) IPlugin* Create_Plugin ()
	{
		//allocate a new object and return it
		return new PluginTest ();
	}
	
	// Plugin cleanup function
	__declspec(dllexport) void Release_Plugin (IPlugin* p_plugin)
	{
		//we allocated in the factory with new, delete the passed object
		delete p_plugin;
	}
	
}


// this is the name that will appear in the object library
extern "C" __declspec(dllexport) char* GetPluginName()
{
	
	
	return "Andy's Color Transfer";
	
}


// This MUST be unique string for each plugin so we can save the data

extern "C" __declspec(dllexport) char* GetPluginID()
{
	
// 	IMPORTANT:you have to fill unique ID for every plugin:
// 	The ID must be unique or loading and saving will not be able to find correct plugin
//  Comment out this line below so you can compile
//	ATTENTION

	return "com.lumafilters.colortransfer";
	
}


// category of plugin, for now the EFFECT go to top library box, everything else goes to the middle library box
extern "C" __declspec(dllexport) int GetCategory()
{
		
	return CATEGORY_BUILDING_BLOCK;
	
}